# 1026.보물

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 2 초      | 128 MB      | 24980 | 14840 | 12716     | 62.745%   |

## 문제

옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.

길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.

S = A[0]×B[0] + ... + A[N-1]×B[N-1]

S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.

S의 최솟값을 출력하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.

## 출력

첫째 줄에 S의 최솟값을 출력한다.

## 예제 입력 1 

```
5
1 1 1 6 0
2 7 8 3 1
```

## 예제 출력 1

```
18
```

## 코드

```python
N = int(input())
A = map(int, input().split())
B = map(int,input().split())

A=sorted(A)
B=sorted(B,reverse=True)

res = 0
for i in range(N):
    res += A[i]*B[i]
print(res)
```

## 풀이

단순하게 생각했다.

첫 번째 케이스는 오름차순으로 정렬해서 각각 곱해보는 것이다.

A : 1 2 3 4 

B : 5 6 7 8 이라고 하면  답은 70

두 번째 케이스는 하나는 오름차순 하나는 내림차순으로 해서 곱해보는 것이다.

A : 1 2 3 4 

B : 8 7 6 5 이라고 하면 답은 60

따라서 최솟값을 구하려면 한열은 오름차순 다른 한 열은 내림차순으로 곱해서 더해주면 된다.

