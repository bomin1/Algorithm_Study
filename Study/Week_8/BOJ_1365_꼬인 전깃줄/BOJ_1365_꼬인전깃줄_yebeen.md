# 1365.꼬인 전깃줄 

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 128 MB      | 3179 | 1673 | 1328      | 55.150%   |

## 문제

공화국에 있는 유스타운 시에서는 길을 사이에 두고 전봇대가 아래와 같이 두 줄로 늘어서 있다. 그리고 길 왼편과 길 오른편의 전봇대는 하나의 전선으로 연결되어 있다. 어떤 전봇대도 두 개 이상의 다른 전봇대와 연결되어 있지는 않다.

![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201004/picpicpicpicpicpicpicp.JPG)

문제는 이 두 전봇대 사이에 있는 전깃줄이 매우 꼬여 있다는 점이다. 꼬여있는 전깃줄은 화재를 유발할 가능성이 있기 때문에 유스타운 시의 시장 임한수는 전격적으로 이 문제를 해결하기로 했다.

임한수는 꼬여 있는 전깃줄 중 몇 개를 적절히 잘라 내어 이 문제를 해결하기로 했다. 하지만 이미 설치해 놓은 전선이 아깝기 때문에 잘라내는 전선을 최소로 하여 꼬여 있는 전선이 하나도 없게 만들려고 한다.

유스타운 시의 시장 임한수를 도와 잘라내야 할 전선의 최소 개수를 구하는 프로그램을 작성하시오.

## 입력

첫 줄에 전봇대의 개수 N(1 ≤ N ≤ 100,000)이 주어지고, 이어서 N보다 작거나 같은 자연수가 N개 주어진다. i번째 줄에 입력되는 자연수는 길 왼쪽에 i번째 전봇대와 연결된 길 오른편의 전봇대가 몇 번 전봇대인지를 나타낸다.

## 출력

전선이 꼬이지 않으려면 최소 몇 개의 전선을 잘라내야 하는 지를 첫째 줄에 출력한다.

## 예제 입력 1 복사

```
4
2 3 4 1
```

## 예제 출력 1 복사

```
1
```

## 나의코드

```python
N = int(input())
line = list(map(int, input().split()))
cnt = 0
for i in range(N-1):
    if line[i] >= line[i+1]:
        print(i)
        cnt += 1
        continue
print(cnt)
# 증가할 때만 전깃줄이 꼬이지 않고
# 다음 수가 작거나 같으면 cnt++ 해주는 거였는데
#모르겠다

```

## 풀이

수열이 증가할 때만 카운트를 안시켜주고 4 1 2 3 인 경우에 4에서 1로 가는 경우가 감소되는 수열이므로 4를 지칭하는 인덱스에서 카운트를 해줬다.

그런데 답이 틀린다. 모르겠다!