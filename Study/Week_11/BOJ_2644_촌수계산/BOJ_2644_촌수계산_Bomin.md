# 2644_촌수계산

> 너비 우선 탐색을 이용한 최단 거리 문제



## 문제

우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.

여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.



## 입력

사람들은 1, 2, 3, …, n (1≤n≤100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.

각 사람의 부모는 최대 한 명만 주어진다.



## 출력

입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.

<br>

---

## Input

```txt
9
7 3
7
1 2
1 3
2 7
2 8
2 9
4 5
4 6
```

## Output

```
3
```

<br>

---

## Code

```python
from collections import deque

def cal():
    q = deque()
    # 내가 찾아야 할 위치를 제일 처음 큐에 넣어준 다음
    q.append(a)
    # 큐를 돌면서
    while q:
        # 해당 위치를 계속 갱신한다.
        now = q.popleft()
        # 지금 위치가 내가 찾아야할 또 다른 위치와 같다면 끝
        if now == b:
            break

        # 같지않다면 지금 노드의 자식노드에 접근을 해서 
        for i in check[now]:
            # 그 자식노드가 방문처리가 되지 않았다면 우선 큐에 넣어준 다음, 방문처리 해주고 해당 위치의 거리는 부모노드의 값에 +1을 한 값을 넣어 갱신해준다. 
            if visited[i] == False:
                q.append(i)
                visited[i] = True
                distance[i] = distance[now] + 1
                

    # 친척관계가 전혀 없다는 말은 이어지지 않았고 이 말은 해당노드의 거리가 0임을 의미한다.
    if distance[b] == 0:
        return -1
    else:
        return distance[b]

# 전체 사람 수
n = int(input())
# 촌수를 계산해야하는 사람의 번호
a,b = map(int, input().split())
# 몇개 있는지
m = int(input())

# 거리 저장 리스트
distance = [0 for _ in range(n+1)]

# 방문체크
visited = [0 for _ in range(n+1)]

# 부모 자식 저상하는 인접 리스트
check = [[] for _ in range(n+1)]

# 부모 자식 관계, 양방향으로 받아옴
for i in range(m):    
    parent, child = map(int, input().split())
    check[parent].append(child)
    check[child].append(parent)

print(cal())
```



## Review

1. 촌수는 거리로 바꿔서 계산을 한다고 생각하면 bfs를 쓴다는 생각이 들었다.
2. 부모와 자식 관계를 인접리스트로 변환해서 저장한 다음에
3. a로부터 시작해서 b를만나면 종료한다.
4. 큐를 이용해서 풀면서 큐에 처음 위치를 저장한 다음에 `q.append(a)`
5. 큐를 계속 돌면서 지금 위치가 b이면 함수를 종료하고 b가 아니라면 지금 위치의 자식 노드에 접근을 해서 자식노드에 방문을 하지않았다면 그 자식노드의 거리를 지금 거리값에 +1을 해준 뒤 저장하고 방문처리 그리고 해당 자식노드를 다시 큐에 넣어준다.
6. 이렇게 하면서 친척관계가 전혀 없다는 말은 이어지지 않았고 이 말은 해당노드의 거리가 0임을 의미한다.

