# 2217.로프 

| 시간 제한 | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :---- | :---- | :-------- | :-------- |
| 2 초      | 192 MB      | 25873 | 11118 | 9056      | 42.792%   |

## 문제

N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.

하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.

각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.

## 입력

첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.

## 출력

첫째 줄에 답을 출력한다.

## 예제 입력 1

```
2
10
15
```

## 예제 출력 1 

```
20
```

## 코드

```python
N = int(input())
rope = []
for i in range(N):
    rope.append(int(input()))
rope.sort()
rope.reverse() #내림차순 정렬
ans = []
for i in range(N):
    ans.append(rope[i] * (i+1))

print(max(ans))
```

## 풀이

입력 값이 

3

5

7

12 라면

![img](https://blog.kakaocdn.net/dn/loaYG/btq2XaeUKLu/eWLZ5Gi7p4bNkCkKQUJntK/img.png)

무게가 가장 많이 나가는 값은 해당하는 하나의 로프에만 가능하고 가장 작은 무게를 가진 로프는 모든 로프의 개수에 가능 하기 때문에 내림차순 정렬을 해서 인덱스 간의 곱으로 풀이를 했다.



따라서 먼저 sort()함수를 사용하여 오름차순 정렬을 한 다음에 reverse()함수를 사용하여 내림차순으로 정렬을 했다.

그러면 rope = [12, 7, 5]가 되는데, 리스트 인덱스는 0부터 시작하기 때문에 인덱스+1를 해준 값을 각 원소마다 곱해주었다. 이 곱해준 값들을 다 저장해 놓고 최대값을 뽑으면 된다.